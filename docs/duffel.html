<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Square-Sided Duffel Pattern Builder</title>
  <style>
    :root{
      --bg:#faf7f1;
      --card:#ffffff;
      --ink:#1a1a1a;
      --muted:#5b5b5b;
      --line:#e6dfd3;
      --accent:#2b2b2b;
      --warn:#7a1f1f;
      --ok:#1e6b3a;
    }
    *{box-sizing:border-box;}
    body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font-family: ui-serif, Georgia, "Times New Roman", Times, serif;
      line-height:1.35;
    }
    header{
      padding:22px 16px 12px;
      text-align:center;
    }
    h1{
      margin:0;
      font-size: clamp(22px, 3vw, 34px);
      letter-spacing:.2px;
    }
    header p{
      margin:10px auto 0;
      max-width: 820px;
      color:var(--muted);
      font-size: 15px;
    }
    main{
      padding: 12px 12px 40px;
      display:flex;
      justify-content:center;
    }
    .wrap{
      width: min(980px, 100%);
      display:grid;
      gap:12px;
    }
    .card{
      background:var(--card);
      border:1px solid var(--line);
      border-radius:18px;
      padding:16px;
      box-shadow: 0 1px 0 rgba(0,0,0,.03);
    }
    .row{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }
    @media (min-width: 860px){
      .row.two{ grid-template-columns: 1fr 1fr; }
      .row.three{ grid-template-columns: 1fr 1fr 1fr; }
      .row.four{ grid-template-columns: 1fr 1fr 1fr 1fr; }
    }
    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
      text-align:center;
    }
    label{
      font-size: 13px;
      color:var(--muted);
    }
    input, select, textarea{
      font-family: inherit;
      font-size: 16px;
      padding: 10px 12px;
      border:1px solid var(--line);
      border-radius: 12px;
      outline: none;
      background:#fff;
      text-align:center;
    }
    textarea{ text-align:left; min-height: 90px; }
    input:focus, select:focus, textarea:focus{
      border-color:#cdbfae;
      box-shadow: 0 0 0 3px rgba(205,191,174,.25);
    }
    .pillbar{
      display:flex;
      gap:8px;
      justify-content:center;
      flex-wrap:wrap;
      margin-top: 6px;
    }
    .pill{
      border:1px solid var(--line);
      background:#fff;
      padding: 8px 10px;
      border-radius: 999px;
      cursor:pointer;
      user-select:none;
      font-size: 14px;
    }
    .pill[aria-pressed="true"]{
      border-color:#b9a88f;
      background:#f7f0e4;
    }
    .btnbar{
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 12px;
    }
    button{
      font-family: inherit;
      border:1px solid var(--accent);
      background: var(--accent);
      color:#fff;
      padding: 10px 14px;
      border-radius: 999px;
      font-size: 15px;
      cursor:pointer;
    }
    button.secondary{
      background:#fff;
      color: var(--accent);
      border-color: var(--line);
    }
    button:disabled{ opacity:.5; cursor:not-allowed; }
    .stepper{
      display:flex;
      justify-content:center;
      gap:8px;
      flex-wrap:wrap;
      margin-top: 10px;
    }
    .dot{
      width: 10px;
      height: 10px;
      border-radius: 999px;
      border:1px solid var(--line);
      background:#fff;
    }
    .dot.active{ background:#b9a88f; border-color:#b9a88f; }

    .kpi{
      text-align:center;
      margin: 4px 0 0;
      color: var(--muted);
      font-size: 13px;
    }

    .hr{ height:1px; background: var(--line); margin: 12px 0; }

    .notice{
      border: 1px solid var(--line);
      background: #fff;
      border-radius: 14px;
      padding: 12px;
      text-align:center;
      color: var(--muted);
      font-size: 14px;
    }
    .notice.ok{ border-color: rgba(30,107,58,.25); background: rgba(30,107,58,.06); color: #164e2a; }
    .notice.warn{ border-color: rgba(122,31,31,.25); background: rgba(122,31,31,.06); color: #5c1616; }

    h2{ text-align:center; margin:0; font-size: 20px; }
    h3{ text-align:center; margin: 0 0 10px; font-size: 18px; }

    table{
      width:100%;
      border-collapse: collapse;
      font-size: 14px;
      overflow:hidden;
      border-radius: 14px;
      border:1px solid var(--line);
    }
    th, td{
      padding: 10px 10px;
      border-bottom:1px solid var(--line);
      text-align:center;
    }
    th{ background:#fbf7ef; }
    tr:last-child td{ border-bottom:none; }

    .grid2{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    @media (min-width: 900px){
      .grid2{ grid-template-columns: 1.15fr .85fr; }
    }

    .vizWrap{
      display:grid;
      gap:12px;
    }
    .vizCard{
      border:1px solid var(--line);
      border-radius: 16px;
      padding: 12px;
      background:#fff;
    }
    canvas{ width:100%; height:auto; display:block; }
    .small{ font-size: 12px; color: var(--muted); text-align:center; }

    .mono{ font-family: ui-monospace, Menlo, Consolas, monospace; font-size: 12px; }

    .hidden{ display:none !important; }

    .footer{
      text-align:center;
      color: var(--muted);
      font-size: 12px;
      padding: 8px 16px 30px;
    }
    .linklike{ text-decoration: underline; cursor:pointer; }
  </style>
</head>
<body>
  <header>
    <h1>Square-Sided Duffel Pattern Builder</h1>
    <p>Panel-built, sharp-corner duffel patterns with cut lists, fabric checks, and step-by-step assembly. Designed for boxy ends and lifetime canvas construction.</p>
    <div class="stepper" id="stepper"></div>
    <div class="kpi" id="stepTitle"></div>
  </header>

  <main>
    <div class="wrap">

      <section class="card" id="wizard"></section>

      <section class="card hidden" id="results">
        <h2>Generated Pattern</h2>
        <p class="kpi" id="summaryLine"></p>
        <div class="hr"></div>

        <div id="fitNotice" class="notice"></div>

        <div class="hr"></div>

        <div class="grid2">
          <div>
            <h3>Cut List</h3>
            <div class="small">All cut sizes include seam allowance unless noted. “Finished” sizes are after seams.</div>
            <div class="hr"></div>
            <div id="cutTables"></div>
          </div>
          <div>
            <h3>Assembly Instructions</h3>
            <div class="small">Generated from your choices (lined/unlined, extra bottom, handle style).</div>
            <div class="hr"></div>
            <div id="instructions"></div>
          </div>
        </div>

        <div class="hr"></div>
        <h3>Pattern Visualizations (per fabric)</h3>
        <div class="small">Simple “shelf” layout (row packing). Orientation arrows show the 36" length direction. Rotate pieces only if you allow it in your fabric settings.</div>
        <div class="hr"></div>
        <div id="visuals" class="vizWrap"></div>

        <div class="btnbar">
          <button class="secondary" id="backToEdit">Edit Inputs</button>
          <button id="printBtn">Print / Save PDF</button>
          <button class="secondary" id="exportJson">Export JSON</button>
        </div>
      </section>

      <div class="footer">
        Tip: For very heavy canvas, lengthen stitch to 3–3.5mm and use bonded poly/nylon thread (Tex 70–90) and a size 16–18 needle.
      </div>

    </div>
  </main>

<script>
/**
 * Duffel Pattern Builder
 * - Panel-built rectangular tube for sharp corners.
 * - Optional lining, extra bottom layer, and fabric-only handles.
 * - Fabric fit uses a simple shelf/row packing algorithm per material.
 설명: Accurate enough for planning; for production, you can enhance packing and add UI for multiple fabric rectangles.
 */

// ---------- Helpers ----------
const $ = (sel) => document.querySelector(sel);
const el = (tag, attrs={}, children=[]) => {
  const n = document.createElement(tag);
  Object.entries(attrs).forEach(([k,v]) => {
    if(k === 'class') n.className = v;
    else if(k === 'html') n.innerHTML = v;
    else if(k.startsWith('on') && typeof v === 'function') n.addEventListener(k.slice(2).toLowerCase(), v);
    else n.setAttribute(k, v);
  });
  (Array.isArray(children) ? children : [children]).forEach(c => {
    if(c == null) return;
    if(typeof c === 'string') n.appendChild(document.createTextNode(c));
    else n.appendChild(c);
  });
  return n;
};

const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
const round2 = (x) => Math.round(x*100)/100;

function inches(x){
  const v = Number(x);
  return Number.isFinite(v) ? v : 0;
}

function fmtIn(x){
  // show quarters nicely
  const v = round2(x);
  const whole = Math.floor(v);
  const frac = v - whole;
  const q = Math.round(frac * 4);
  if(q === 0) return `${whole}"`;
  if(q === 4) return `${whole+1}"`;
  const map = {1:'1/4',2:'1/2',3:'3/4'};
  return whole === 0 ? `${map[q]}"` : `${whole} ${map[q]}"`;
}

function areaSqIn(rects){
  return rects.reduce((s,r)=>s + r.w*r.h, 0);
}

// ---------- Domain model ----------
/**
 * Pattern model choices:
 * - Bag is a rectangular prism: Length (L), Depth (D), Height (H)
 * - Panel construction:
 *   - 2 x Side panels: L x H (handle side faces)
 *   - 2 x Side panels: L x H (opposite handle side)  [same size]
 *   - 2 x End panels: D x H
 *   - 1 x Bottom panel: L x D
 * - Top: open; optionally add fold-over hem height (storm cuff)
 */

const DEFAULTS = {
  units: 'in',
  bag: { L: 36, D: 14, H: 14 },
  seamAllowance: 0.5,
  topHem: 2.0, // total visible cuff depth (folded). We'll plan as 2" double fold (1"+1") or a single fold.
  lined: true,
  extraBottom: true,
  handleStyle: 'hand', // hand | shoulder | both | none
  handleMaterial: 'Canvas (same)',
  handleDropHand: 8.5,
  handleDropShoulder: 18,
  handleFinishedWidth: 1.75,
  handleFoldedFromWidth: 6, // cut width
  handleAttachmentSpan: 24, // along length on top
  allowRotateInFabric: true,
  // Fabric per material (single rectangle each for simplicity)
  fabrics: {
    body: { name:'Main body', width: 60, length: 80 },
    lining: { name:'Lining', width: 60, length: 80 },
    handles: { name:'Handles', width: 60, length: 20 },
    bottom: { name:'Extra bottom', width: 60, length: 20 },
  },
  colors: {
    body: 'Body fabric',
    lining: 'Lining fabric',
    handles: 'Handle fabric',
    bottom: 'Bottom reinforcement fabric'
  }
};

function deepClone(o){ return JSON.parse(JSON.stringify(o)); }

// ---------- Pattern generation ----------

function validateInputs(state){
  const errs = [];
  const L = inches(state.bag.L), D = inches(state.bag.D), H = inches(state.bag.H);
  const sa = inches(state.seamAllowance);
  if(L <= 0 || D <= 0 || H <= 0) errs.push('Bag dimensions must be positive.');
  if(sa < 0 || sa > 2) errs.push('Seam allowance should be between 0" and 2".');
  if(D < 4 || H < 4 || L < 10) errs.push('Those dimensions are extremely small for a duffel; double-check.');

  // Handle logic sanity
  if(state.handleStyle === 'shoulder' || state.handleStyle === 'both'){
    if(inches(state.handleDropShoulder) < 12) errs.push('Shoulder strap handle drop is very small; consider 16–22".');
  }
  if(state.handleStyle === 'hand' || state.handleStyle === 'both'){
    if(inches(state.handleDropHand) < 6) errs.push('Hand handle drop below 6" may feel tight.');
  }
  return errs;
}

function makePieces(state){
  const L = inches(state.bag.L), D = inches(state.bag.D), H = inches(state.bag.H);
  const sa = inches(state.seamAllowance);
  const topHem = inches(state.topHem);

  // Panel heights include extra for top hem (outer shell + lining). For lining we reduce slightly later.
  const cutH_outer = H + topHem; // outer panels include hem allowance
  const cutH_lining = H + Math.max(0, topHem - 0.75); // lining slightly shorter to sit under hem cleanly

  // Core body panel cut sizes
  const sideW = L; // finished
  const sideH = H; // finished
  const endW = D;
  const endH = H;
  const bottomW = L;
  const bottomH = D;

  // Cut sizes include seam allowance on all joining edges.
  // For panel seams: add SA left+right = +2*SA; bottom seam +SA; top hem already accounted.
  const side_cut_w = sideW + 2*sa;
  const side_cut_h = cutH_outer + sa; // bottom seam allowance

  const end_cut_w = endW + 2*sa;
  const end_cut_h = cutH_outer + sa;

  const bottom_cut_w = bottomW + 2*sa;
  const bottom_cut_h = bottomH + 2*sa;

  const pieces = [];

  // Outer body
  for(let i=1;i<=4;i++){
    pieces.push({
      id:`OUTER_SIDE_${i}`,
      label:`Outer side panel ${i} (L×H)`,
      material:'body',
      colorKey:'body',
      count:1,
      finished:{ w: sideW, h: sideH },
      cut:{ w: side_cut_w, h: side_cut_h },
      grain:`Length (L=${L}") runs horizontally`,
      notes:'Includes top hem allowance and bottom seam allowance.'
    });
  }
  pieces.push({
    id:'OUTER_BOTTOM',
    label:'Outer bottom (L×D)',
    material:'body',
    colorKey:'body',
    count:1,
    finished:{ w: bottomW, h: bottomH },
    cut:{ w: bottom_cut_w, h: bottom_cut_h },
    grain:'Length (L) runs horizontally',
    notes:'Stitch to tube; corners clipped/notched during assembly.'
  });
  for(let i=1;i<=2;i++){
    pieces.push({
      id:`OUTER_END_${i}`,
      label:`Outer end panel ${i} (D×H)`,
      material:'body',
      colorKey:'body',
      count:1,
      finished:{ w: endW, h: endH },
      cut:{ w: end_cut_w, h: end_cut_h },
      grain:'Depth (D) runs horizontally',
      notes:'Attach after bottom for crisp corners.'
    });
  }

  // Lining
  if(state.lined){
    const side_cut_h_L = cutH_lining + sa;
    const end_cut_h_L = cutH_lining + sa;

    for(let i=1;i<=4;i++){
      pieces.push({
        id:`LINING_SIDE_${i}`,
        label:`Lining side panel ${i} (L×H)`,
        material:'lining',
        colorKey:'lining',
        count:1,
        finished:{ w: sideW, h: sideH },
        cut:{ w: side_cut_w, h: side_cut_h_L },
        grain:`Length (L=${L}") runs horizontally`,
        notes:'Slightly shorter than outer for clean hem.'
      });
    }
    pieces.push({
      id:'LINING_BOTTOM',
      label:'Lining bottom (L×D)',
      material:'lining',
      colorKey:'lining',
      count:1,
      finished:{ w: bottomW, h: bottomH },
      cut:{ w: bottom_cut_w, h: bottom_cut_h },
      grain:'Length (L) runs horizontally',
      notes:'Consider leaving a 6–8" turning opening in one seam.'
    });
    for(let i=1;i<=2;i++){
      pieces.push({
        id:`LINING_END_${i}`,
        label:`Lining end panel ${i} (D×H)`,
        material:'lining',
        colorKey:'lining',
        count:1,
        finished:{ w: endW, h: endH },
        cut:{ w: end_cut_w, h: end_cut_h_L },
        grain:'Depth (D) runs horizontally',
        notes:'Match notches to outer for easier insertion.'
      });
    }
  }

  // Extra bottom layer
  if(state.extraBottom){
    pieces.push({
      id:'BOTTOM_REINF',
      label:'Extra bottom reinforcement (L×D)',
      material: state.lined ? 'bottom' : 'body',
      colorKey:'bottom',
      count:1,
      finished:{ w: bottomW, h: bottomH },
      cut:{ w: bottom_cut_w, h: bottom_cut_h },
      grain:'Length (L) runs horizontally',
      notes:'Baste to outer bottom (wrong side) before assembly.'
    });
  }

  // Handles (canvas-only straps)
  const handlePieces = makeHandlePieces(state);
  pieces.push(...handlePieces);

  return pieces;
}

function makeHandlePieces(state){
  const L = inches(state.bag.L);
  const D = inches(state.bag.D);
  const sa = inches(state.seamAllowance);

  // Wrap-under handle run recommendation:
  // handle strap length ≈ bottom run (L) + 2*side up-and-over (H + D/2) + extra for turns & grip.
  // We compute from user-selected drops for the top portion.

  const handleFromW = inches(state.handleFoldedFromWidth);
  const attachSpan = inches(state.handleAttachmentSpan);

  // Determine top carry style: hand, shoulder, or both.
  // We’ll generate straps that wrap under the bottom and form two handles.
  // If both: we’ll generate 2 sets (hand + shoulder) OR recommend making shoulder strap separate.

  const pieces = [];

  const handleMaterial = (state.handleMaterial === 'Canvas (same)') ? 'body' : 'handles';
  const colorKey = (state.handleMaterial === 'Canvas (same)') ? 'body' : 'handles';

  // Under-bottom wrap strap length formula
  // Let: top distance between anchor points on each side along length = attachSpan
  // Each side has a handle arc: approximately 2*drop + attachSpan.
  // Total strap length (one continuous strap) = 2*side run over top + 2*vertical sides + bottom run.
  // For classic wrap-under with two handles: we usually use TWO separate long straps,
  // each one creates both handles on one side pair. Each strap length roughly:
  //   = bottom run (L) + 2*(side wall rise (D + H)?)
  // For panel-built, the strap typically goes:
  //   up one side face -> under bottom -> up other side face.
  // If anchored near the top hem, the climb height approx H (finished) + hem edge offset.
  const climb = inches(state.bag.H) + 1.0; // include into hem/attachment zone

  function strapLengthForDrop(drop){
    // If you want a certain handle drop, the strap needs additional slack above anchor points.
    // Approx top slack over anchors: 2*drop + attachSpan (two arcs + span).
    // But the strap is continuous: the top portion is two handles + mid span.
    // Empirically: add (2*drop + attachSpan) - (2*anchorSpacing) ???
    // To keep it accurate and useful, we compute a conservative length:
    // base wrap-under length + extraHandleSlack.
    const base = L + 2*climb + 2*D; // under + up and over curves (depth influences turning)
    const slack = 2*drop + attachSpan; // forms comfortable handle arcs
    return base + slack;
  }

  const wantsHand = state.handleStyle === 'hand' || state.handleStyle === 'both';
  const wantsShoulder = state.handleStyle === 'shoulder' || state.handleStyle === 'both';

  if(wantsHand){
    const len = strapLengthForDrop(inches(state.handleDropHand));
    pieces.push({
      id:'HANDLE_STRAP_HAND_A',
      label:'Handle strap A (wrap-under, hand carry)',
      material: handleMaterial,
      colorKey,
      count:1,
      finished:{ w: inches(state.handleFinishedWidth), h: len },
      cut:{ w: handleFromW, h: len + 2*sa },
      grain:'Cut long direction along strong grain',
      notes:`Fold to ~${fmtIn(inches(state.handleFinishedWidth))} width. Length includes slack for ~${fmtIn(inches(state.handleDropHand))} drop.`
    });
    pieces.push({
      id:'HANDLE_STRAP_HAND_B',
      label:'Handle strap B (wrap-under, hand carry)',
      material: handleMaterial,
      colorKey,
      count:1,
      finished:{ w: inches(state.handleFinishedWidth), h: len },
      cut:{ w: handleFromW, h: len + 2*sa },
      grain:'Cut long direction along strong grain',
      notes:'Second strap mirrors first.'
    });
  }

  if(wantsShoulder){
    // Most sewists prefer a dedicated detachable shoulder strap.
    // But if user selected shoulder handles, we generate longer wrap-under straps.
    const len = strapLengthForDrop(inches(state.handleDropShoulder));
    pieces.push({
      id:'HANDLE_STRAP_SHOULDER_A',
      label:'Handle strap A (wrap-under, shoulder carry)',
      material: handleMaterial,
      colorKey,
      count:1,
      finished:{ w: inches(state.handleFinishedWidth), h: len },
      cut:{ w: handleFromW, h: len + 2*sa },
      grain:'Cut long direction along strong grain',
      notes:`Longer strap for ~${fmtIn(inches(state.handleDropShoulder))} drop. Consider adding shoulder pad.`
    });
    pieces.push({
      id:'HANDLE_STRAP_SHOULDER_B',
      label:'Handle strap B (wrap-under, shoulder carry)',
      material: handleMaterial,
      colorKey,
      count:1,
      finished:{ w: inches(state.handleFinishedWidth), h: len },
      cut:{ w: handleFromW, h: len + 2*sa },
      grain:'Cut long direction along strong grain',
      notes:'Second strap mirrors first.'
    });
  }

  // Reinforcement patches at handle entry zones
  const patchW = 4.5, patchH = 6.0;
  pieces.push({
    id:'HANDLE_PATCHES',
    label:'Handle reinforcement patches',
    material: handleMaterial,
    colorKey,
    count:8,
    finished:{ w: patchW, h: patchH },
    cut:{ w: patchW + 2*sa, h: patchH + 2*sa },
    grain:'Any',
    notes:'Place inside bag where straps climb the sides. Round corners for durability.'
  });

  return pieces;
}

// ---------- Fabric fit (simple shelf packing) ----------

/**
 * Pack rectangles into a single fabric rectangle (W x H) using shelf algorithm.
 * - Tries to place each piece in rows.
 * - Optionally allows rotation.
 * Returns placement list and fit boolean.
 */
function packShelf(rects, fabricW, fabricH, allowRotate=true){
  const placements = [];
  let x = 0, y = 0;
  let rowH = 0;

  const sorted = [...rects].sort((a,b)=> (Math.max(b.w,b.h)-Math.max(a.w,a.h)) || (b.h-a.h));

  for(const r of sorted){
    let w = r.w, h = r.h;
    let rotated = false;

    function fitsHere(w2,h2){
      return (x + w2 <= fabricW) && (y + h2 <= fabricH);
    }

    // If doesn't fit in current row, start new row
    if(!fitsHere(w,h)){
      // try rotate in same row
      if(allowRotate && fitsHere(h,w)){
        [w,h] = [h,w];
        rotated = true;
      } else {
        // new row
        y += rowH;
        x = 0;
        rowH = 0;
        if(!fitsHere(w,h)){
          if(allowRotate && fitsHere(h,w)){
            [w,h] = [h,w];
            rotated = true;
          }
        }
      }
    }

    if(!fitsHere(w,h)){
      return { ok:false, placements, usedW:fabricW, usedH:fabricH };
    }

    placements.push({
      id:r.id,
      label:r.label,
      x, y, w, h,
      rotated,
      meta:r
    });

    x += w;
    rowH = Math.max(rowH, h);
  }

  return { ok:true, placements, usedW:fabricW, usedH: Math.min(fabricH, y+rowH) };
}

function computeFabricPlan(state, pieces){
  // Group rectangles per material. Each piece count expands into rectangles.
  const perMat = new Map();
  for(const p of pieces){
    const mat = p.material;
    if(!perMat.has(mat)) perMat.set(mat, []);
    for(let i=0;i<p.count;i++){
      perMat.get(mat).push({
        id:`${p.id}#${i+1}`,
        label: p.count>1 ? `${p.label} (${i+1}/${p.count})` : p.label,
        w: p.cut.w,
        h: p.cut.h,
        meta: p
      });
    }
  }

  const results = [];
  let allOk = true;

  for(const [mat, rects] of perMat.entries()){
    const fab = fabricForMaterial(state, mat);
    const pack = packShelf(rects, fab.width, fab.length, state.allowRotateInFabric);
    allOk = allOk && pack.ok;
    results.push({
      material: mat,
      materialName: fab.name,
      fabric: fab,
      rects,
      pack
    });
  }

  return { allOk, byMaterial: results };
}

function fabricForMaterial(state, material){
  // Map materials to user fabrics
  // body -> fabrics.body, lining -> fabrics.lining, handles -> fabrics.handles, bottom -> fabrics.bottom
  if(material === 'body') return state.fabrics.body;
  if(material === 'lining') return state.fabrics.lining;
  if(material === 'handles') return state.fabrics.handles;
  if(material === 'bottom') return state.fabrics.bottom;
  // fallback
  return state.fabrics.body;
}

// ---------- Cut list tables ----------

function groupPiecesForDisplay(state, pieces){
  // Group by colorKey (body/lining/handles/bottom) for “fabric colors” output
  const groups = new Map();
  for(const p of pieces){
    const key = p.colorKey || p.material;
    if(!groups.has(key)) groups.set(key, []);
    groups.get(key).push(p);
  }
  return groups;
}

function renderCutTables(state, pieces){
  const groups = groupPiecesForDisplay(state, pieces);
  const host = el('div');

  for(const [key, list] of groups.entries()){
    const title = state.colors[key] || key;
    const table = el('table');
    table.appendChild(el('thead',{},[
      el('tr',{},[
        el('th',{},'Piece'),
        el('th',{},'Qty'),
        el('th',{},'Cut (W × H)'),
        el('th',{},'Finished (W × H)'),
        el('th',{},'Notes')
      ])
    ]));

    const tb = el('tbody');
    for(const p of list){
      const cutWH = `${fmtIn(p.cut.w)} × ${fmtIn(p.cut.h)}`;
      const finWH = `${fmtIn(p.finished.w)} × ${fmtIn(p.finished.h)}`;
      tb.appendChild(el('tr',{},[
        el('td',{},p.label),
        el('td',{},String(p.count)),
        el('td',{},cutWH),
        el('td',{},finWH),
        el('td',{},p.notes || '')
      ]));
    }
    table.appendChild(tb);

    host.appendChild(el('div', {class:'vizCard'}, [
      el('div', {class:'small', html:`<b>${title}</b> · ${list[0]?.material ?? ''}`}),
      el('div', {style:'height:10px'}),
      table
    ]));
  }

  return host;
}

// ---------- Instructions generation ----------

function generateInstructions(state){
  const L = inches(state.bag.L), D = inches(state.bag.D), H = inches(state.bag.H);
  const sa = inches(state.seamAllowance);
  const topHem = inches(state.topHem);

  const steps = [];

  steps.push({
    title:'0) Prep & Mark',
    body:[
      `Pre-wash and dry your canvas if you expect shrinkage. Press flat.`,
      `Transfer seam allowance: ${fmtIn(sa)}. Mark wrong sides clearly (chalk or tape).`,
      `On all panels, mark quarter points (midpoints) on each edge to help align corners crisply.`
    ]
  });

  steps.push({
    title:'1) Cut Pieces',
    body:[
      `Cut all pieces per the Cut List. Keep grain consistent: length direction (L=${L}") should run along the strongest grain where possible.`,
      state.extraBottom ? `Also cut the extra bottom layer and label it “Bottom Reinforcement.”` : ``,
      (state.handleStyle !== 'none') ? `Cut handle straps. Fold and stitch them into finished straps before attaching to the bag.` : ``
    ].filter(Boolean)
  });

  // Handle steps
  if(state.handleStyle !== 'none'){
    steps.push({
      title:'2) Make Canvas Handles (folded straps)',
      body:[
        `For each strap: fold long edges to center, then fold in half again to hide raw edges.`,
        `Topstitch both long edges (2 parallel rows). Use longer stitch length (3–3.5mm) and heavy thread.`,
        `Optional: add an extra scrap strip inside for a cushier handle.`
      ]
    });
  }

  steps.push({
    title:'3) Assemble Outer Tube (sharp corners)',
    body:[
      `Sew the four outer side panels edge-to-edge to form a rectangular tube (Right sides together).`,
      `Press seams open for crisp corners. Optional: topstitch 3/8" from each seam on both sides for strength and a “heritage” look.`,
      `Do a quick “dry fit” by standing the tube up to confirm square corners.`
    ]
  });

  if(state.extraBottom){
    steps.push({
      title:'4) Reinforce the Bottom',
      body:[
        `Place the extra bottom layer on the wrong side of the outer bottom piece. Baste around the perimeter inside the seam allowance.`,
        `If adding a removable stiffener later, you can create a pocket by stitching only 3 sides and leaving one short edge open inside the lining.`
      ]
    });
  }

  steps.push({
    title:'5) Attach Outer Bottom',
    body:[
      `With right sides together, pin/clip the bottom panel to the outer tube. Match midpoints and corners first.`,
      `Stitch all four sides at ${fmtIn(sa)} seam allowance.`,
      `At each corner: clip into seam allowance (do not cut stitches) so the corner turns sharply without puckers.`
    ]
  });

  steps.push({
    title:'6) Attach Outer End Panels',
    body:[
      `Attach end panels one at a time. Align top edges and corner marks.`,
      `Stitch around perimeter. Clip seam allowance at corners for crisp turning.`
    ]
  });

  if(state.handleStyle !== 'none'){
    steps.push({
      title:'7) Install Handles (wrap-under)',
      body:[
        `Mark handle placement on the outer shell: centered on each long side, with symmetrical spacing.`,
        `Run straps up the side, across the bottom, and up the opposite side. Ensure straps sit straight and don’t twist.`,
        `Inside the bag, position reinforcement patches behind strap zones.`,
        `Stitch straps down with a box-X at the top anchor zones and bar tacks at stress points. Keep stitches inside top hem area if possible.`
      ]
    });
  }

  if(state.lined){
    steps.push({
      title:'8) Assemble Lining',
      body:[
        `Sew lining side panels into a tube. Press seams.`,
        `Attach lining bottom, then lining end panels.`,
        `Leave a 6–8" opening in one seam (or in the bottom seam) for turning if you plan to fully bag the lining.`
      ]
    });

    steps.push({
      title:'9) Join Lining to Outer (bagging method)',
      body:[
        `Insert lining into outer shell, right sides together at the top edge. Align seams and midpoints.`,
        `Stitch around the top edge.`,
        `Turn through the lining opening, then close the opening with a topstitch or ladder stitch.`
      ]
    });
  }

  steps.push({
    title:'10) Top Hem / Cuff (no zipper)',
    body:[
      `Form the top hem/cuff: fold down ${fmtIn(topHem/2)} then fold again ${fmtIn(topHem/2)} to hide raw edge (adjust if you prefer a single deep fold).`,
      `Topstitch around the entire opening. Add a second row 1/4" below for stiffness.`,
      `Optional closure: add a center strap + buckle, snaps, or a toggle loop.`
    ]
  });

  steps.push({
    title:'11) Final Reinforcement',
    body:[
      `Topstitch along bottom seams if your machine can handle the thickness; this dramatically increases durability.`,
      `Bar tack or zig-zag at the end of each seam line near corners to prevent seam creep.`,
      `Load test: add weight gradually and check any stress areas; re-stitch if needed.`
    ]
  });

  return steps;
}

function renderInstructions(steps){
  const host = el('div');
  for(const s of steps){
    host.appendChild(el('div', {class:'vizCard'}, [
      el('div', {style:'text-align:center; font-weight:700; margin-bottom:6px;'}, s.title),
      el('ul', {style:'margin:0; padding-left: 18px; text-align:left;'},
        s.body.map(t => el('li',{}, t))
      )
    ]));
  }
  return host;
}

// ---------- Visualization ----------

function drawPlan(canvas, pack, fabric){
  const ctx = canvas.getContext('2d');
  // crisp scaling for high DPI
  const dpr = window.devicePixelRatio || 1;
  const w = canvas.clientWidth;
  const targetH = Math.max(220, Math.round(w * 0.55));
  canvas.width = Math.round(w * dpr);
  canvas.height = Math.round(targetH * dpr);
  ctx.scale(dpr, dpr);

  // background
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0,0,w,targetH);

  // scale fabric to fit
  const pad = 18;
  const availW = w - 2*pad;
  const availH = targetH - 2*pad - 28;

  const scale = Math.min(availW / fabric.width, availH / fabric.length);

  const fw = fabric.width * scale;
  const fh = fabric.length * scale;

  const ox = (w - fw)/2;
  const oy = pad + 18;

  // fabric outline
  ctx.strokeStyle = '#cdbfae';
  ctx.lineWidth = 2;
  ctx.strokeRect(ox, oy, fw, fh);

  // label
  ctx.fillStyle = '#1a1a1a';
  ctx.font = '14px ui-serif, Georgia, serif';
  ctx.textAlign = 'center';
  ctx.fillText(`${fabric.name}: ${fabric.width}" × ${fabric.length}"`, w/2, 18);

  // pieces
  ctx.font = '11px ui-serif, Georgia, serif';
  ctx.textAlign = 'left';

  for(const p of pack.placements){
    const x = ox + p.x * scale;
    const y = oy + p.y * scale;
    const pw = p.w * scale;
    const ph = p.h * scale;

    // neutral fill with outline
    ctx.fillStyle = '#fbf7ef';
    ctx.strokeStyle = '#2b2b2b';
    ctx.lineWidth = 1;
    ctx.fillRect(x,y,pw,ph);
    ctx.strokeRect(x,y,pw,ph);

    // orientation arrow (show “length direction” along meta finished width when meaningful)
    ctx.strokeStyle = '#2b2b2b';
    ctx.lineWidth = 1;
    ctx.beginPath();
    // Arrow along longer axis
    const alongX = pw >= ph;
    const ax1 = x + pw*0.15;
    const ay1 = y + ph*0.5;
    const ax2 = x + pw*0.85;
    const ay2 = y + ph*0.5;
    const bx1 = x + pw*0.5;
    const by1 = y + ph*0.15;
    const bx2 = x + pw*0.5;
    const by2 = y + ph*0.85;

    if(alongX){
      ctx.moveTo(ax1, ay1);
      ctx.lineTo(ax2, ay2);
      // arrow head
      ctx.lineTo(ax2-6, ay2-3);
      ctx.moveTo(ax2, ay2);
      ctx.lineTo(ax2-6, ay2+3);
    } else {
      ctx.moveTo(bx1, by1);
      ctx.lineTo(bx2, by2);
      ctx.lineTo(bx2-3, by2-6);
      ctx.moveTo(bx2, by2);
      ctx.lineTo(bx2+3, by2-6);
    }
    ctx.stroke();

    // label
    const label = p.label.replace(/\s+\(.*\)$/,'');
    ctx.fillStyle = '#1a1a1a';
    ctx.textAlign = 'left';
    ctx.fillText(label.slice(0,22) + (label.length>22?'…':''), x+6, y+14);

    ctx.fillStyle = '#5b5b5b';
    ctx.fillText(`${round2(p.w)}"×${round2(p.h)}"${p.rotated?' (rot)':''}`, x+6, y+28);
  }

  // ok/warn
  ctx.textAlign = 'center';
  ctx.font = '12px ui-serif, Georgia, serif';
  ctx.fillStyle = pack.ok ? '#164e2a' : '#5c1616';
  ctx.fillText(pack.ok ? 'Layout fits this fabric.' : 'Does NOT fit this fabric. Increase fabric or reduce pieces.', w/2, targetH - 10);
}

function renderVisuals(fabricPlan){
  const host = el('div');
  for(const m of fabricPlan.byMaterial){
    const card = el('div',{class:'vizCard'});
    card.appendChild(el('div',{class:'small', html:`<b>${m.fabric.name}</b> · Used for <span class="mono">${m.material}</span>`}));
    const c = el('canvas');
    c.style.width = '100%';
    c.style.height = 'auto';
    card.appendChild(el('div',{style:'height:10px'}));
    card.appendChild(c);
    card.appendChild(el('div',{class:'small', html:`Pieces: <span class="mono">${m.rects.length}</span> · Approx area needed: <span class="mono">${Math.round(areaSqIn(m.rects))} sq in</span>`}));

    // Defer draw until attached
    requestAnimationFrame(()=> drawPlan(c, m.pack, m.fabric));
    host.appendChild(card);
  }
  return host;
}

// ---------- Wizard UI ----------

const STEPS = [
  { key:'size', title:'Bag size' },
  { key:'options', title:'Build options' },
  { key:'handles', title:'Handles' },
  { key:'fabric', title:'Available fabric' },
  { key:'review', title:'Review & generate' }
];

let state = deepClone(DEFAULTS);
let stepIndex = 0;

function renderStepper(){
  const host = $('#stepper');
  host.innerHTML = '';
  STEPS.forEach((s,i)=>{
    host.appendChild(el('div',{class:`dot ${i===stepIndex?'active':''}` }));
  });
  $('#stepTitle').textContent = `${stepIndex+1}/${STEPS.length} · ${STEPS[stepIndex].title}`;
}

function renderWizard(){
  renderStepper();
  const host = $('#wizard');
  host.innerHTML = '';

  const step = STEPS[stepIndex].key;

  if(step === 'size') host.appendChild(stepSize());
  if(step === 'options') host.appendChild(stepOptions());
  if(step === 'handles') host.appendChild(stepHandles());
  if(step === 'fabric') host.appendChild(stepFabric());
  if(step === 'review') host.appendChild(stepReview());
}

function navButtons(canNext=true){
  const bar = el('div',{class:'btnbar'});
  bar.appendChild(el('button',{class:'secondary', onClick:()=>{ stepIndex = Math.max(0, stepIndex-1); renderWizard(); } , disabled: stepIndex===0}, 'Back'));
  bar.appendChild(el('button',{onClick:()=>{ stepIndex = Math.min(STEPS.length-1, stepIndex+1); renderWizard(); }, disabled: !canNext || stepIndex===STEPS.length-1}, stepIndex === STEPS.length-1 ? 'Next' : 'Next'));
  return bar;
}

function stepSize(){
  const card = el('div');
  card.appendChild(el('h2',{},'Bag size'));
  card.appendChild(el('p',{class:'kpi'},'Enter finished dimensions (inches). Length is along the opening; Depth is end-to-end thickness; Height is from base to top edge.'));

  const r = el('div',{class:'row three'});

  const L = el('div',{class:'field'},[
    el('label',{},'Length (handle side) — L'),
    el('input',{type:'number', min:'10', step:'0.25', value: state.bag.L, onInput:(e)=>{ state.bag.L = inches(e.target.value); }}),
  ]);
  const D = el('div',{class:'field'},[
    el('label',{},'Depth (end panel width) — D'),
    el('input',{type:'number', min:'4', step:'0.25', value: state.bag.D, onInput:(e)=>{ state.bag.D = inches(e.target.value); }}),
  ]);
  const H = el('div',{class:'field'},[
    el('label',{},'Height — H'),
    el('input',{type:'number', min:'4', step:'0.25', value: state.bag.H, onInput:(e)=>{ state.bag.H = inches(e.target.value); }}),
  ]);

  r.appendChild(L); r.appendChild(D); r.appendChild(H);
  card.appendChild(r);

  // quick derived summary
  const vol = Math.round((state.bag.L*state.bag.D*state.bag.H) / 61.0237); // cubic inches to liters approx
  card.appendChild(el('div',{class:'notice'}, `Approx internal volume: ~${vol} L (before lining and seam reductions).`));

  card.appendChild(navButtons(true));
  return card;
}

function stepOptions(){
  const card = el('div');
  card.appendChild(el('h2',{},'Build options'));
  card.appendChild(el('p',{class:'kpi'},'These inputs affect cut sizes and assembly instructions.'));

  const r = el('div',{class:'row two'});

  const seam = el('div',{class:'field'},[
    el('label',{},'Seam allowance'),
    el('input',{type:'number', min:'0', step:'0.125', value: state.seamAllowance, onInput:(e)=>{ state.seamAllowance = inches(e.target.value); }}),
  ]);

  const hem = el('div',{class:'field'},[
    el('label',{},'Top hem / cuff depth (total)'),
    el('input',{type:'number', min:'0', step:'0.25', value: state.topHem, onInput:(e)=>{ state.topHem = inches(e.target.value); }}),
  ]);

  r.appendChild(seam); r.appendChild(hem);
  card.appendChild(r);

  // toggles
  card.appendChild(el('div',{class:'hr'}));
  card.appendChild(el('div',{class:'field'},[
    el('label',{},'Lining'),
    el('div',{class:'pillbar'},[
      togglePill('Lined', state.lined, (v)=> state.lined = v),
      togglePill('Unlined', !state.lined, (v)=> state.lined = !v)
    ])
  ]));

  card.appendChild(el('div',{class:'field'},[
    el('label',{},'Extra bottom layer (bombproof base)'),
    el('div',{class:'pillbar'},[
      togglePill('Yes', state.extraBottom, (v)=> state.extraBottom = v),
      togglePill('No', !state.extraBottom, (v)=> state.extraBottom = !v)
    ])
  ]));

  card.appendChild(el('div',{class:'field'},[
    el('label',{},'Allow rotating pattern pieces to fit fabric'),
    el('div',{class:'pillbar'},[
      togglePill('Allow rotate', state.allowRotateInFabric, (v)=> state.allowRotateInFabric = v),
      togglePill('No rotate', !state.allowRotateInFabric, (v)=> state.allowRotateInFabric = !v)
    ])
  ]));

  card.appendChild(navButtons(true));
  return card;
}

function togglePill(text, pressed, onSet){
  return el('div',{class:'pill', role:'button', tabindex:'0', 'aria-pressed': pressed ? 'true':'false', onClick:()=>{ onSet(!pressed); renderWizard(); }}, text);
}

function stepHandles(){
  const card = el('div');
  card.appendChild(el('h2',{},'Handles'));
  card.appendChild(el('p',{class:'kpi'},'Canvas-only straps, wrap-under for maximum durability. Choose hand carry, shoulder carry, or both.'));

  const style = el('div',{class:'field'},[
    el('label',{},'Handle use case'),
    el('select',{value: state.handleStyle, onChange:(e)=>{ state.handleStyle = e.target.value; renderWizard(); }},[
      el('option',{value:'hand'},'Hand carry'),
      el('option',{value:'shoulder'},'Shoulder carry'),
      el('option',{value:'both'},'Hand + Shoulder (two sets)'),
      el('option',{value:'none'},'No handles (pattern only)')
    ])
  ]);

  const mat = el('div',{class:'field'},[
    el('label',{},'Handle fabric'),
    el('select',{value: state.handleMaterial, onChange:(e)=>{ state.handleMaterial = e.target.value; renderWizard(); }},[
      el('option',{value:'Canvas (same)'},'Canvas (same as body)'),
      el('option',{value:'Separate fabric'},'Separate fabric / color')
    ])
  ]);

  card.appendChild(el('div',{class:'row two'},[style, mat]));

  const r = el('div',{class:'row four'});
  r.appendChild(el('div',{class:'field'},[
    el('label',{},'Finished strap width'),
    el('input',{type:'number', step:'0.25', value: state.handleFinishedWidth, onInput:(e)=>{ state.handleFinishedWidth = inches(e.target.value); }}),
  ]));
  r.appendChild(el('div',{class:'field'},[
    el('label',{},'Cut strap width (folded)'),
    el('input',{type:'number', step:'0.25', value: state.handleFoldedFromWidth, onInput:(e)=>{ state.handleFoldedFromWidth = inches(e.target.value); }}),
  ]));
  r.appendChild(el('div',{class:'field'},[
    el('label',{},'Top span between handle anchors'),
    el('input',{type:'number', step:'0.25', value: state.handleAttachmentSpan, onInput:(e)=>{ state.handleAttachmentSpan = inches(e.target.value); }}),
  ]));
  r.appendChild(el('div',{class:'field'},[
    el('label',{},'Hand drop'),
    el('input',{type:'number', step:'0.25', value: state.handleDropHand, onInput:(e)=>{ state.handleDropHand = inches(e.target.value); }}),
  ]));
  card.appendChild(r);

  if(state.handleStyle === 'shoulder' || state.handleStyle === 'both'){
    card.appendChild(el('div',{class:'row two'},[
      el('div',{class:'field'},[
        el('label',{},'Shoulder drop'),
        el('input',{type:'number', step:'0.25', value: state.handleDropShoulder, onInput:(e)=>{ state.handleDropShoulder = inches(e.target.value); }}),
      ]),
      el('div',{class:'notice'},'Note: Many makers prefer a detachable shoulder strap. Selecting “Shoulder” here generates longer wrap-under straps instead.')
    ]));
  }

  card.appendChild(el('div',{class:'notice'},'Handles are generated as folded canvas straps + reinforcement patches. For maximum durability, straps run under the bottom and up both sides.'));

  card.appendChild(navButtons(true));
  return card;
}

function stepFabric(){
  const card = el('div');
  card.appendChild(el('h2',{},'Available fabric'));
  card.appendChild(el('p',{class:'kpi'},'Enter the usable rectangles for each fabric. Handles can share body fabric if you choose “Canvas (same).”'));

  const fabrics = [
    {key:'body', label:'Main body fabric'},
    {key:'lining', label:'Lining fabric', condition: ()=> state.lined},
    {key:'bottom', label:'Extra bottom fabric', condition: ()=> state.extraBottom && state.lined},
    {key:'handles', label:'Handle fabric', condition: ()=> state.handleMaterial === 'Separate fabric'}
  ];

  for(const f of fabrics){
    if(f.condition && !f.condition()) continue;
    const data = state.fabrics[f.key];
    const colorName = state.colors[f.key];
    const row = el('div',{class:'row two'});
    row.appendChild(el('div',{class:'field'},[
      el('label',{},`${f.label} width (usable)`),
      el('input',{type:'number', step:'0.5', value:data.width, onInput:(e)=>{ data.width = inches(e.target.value); }}),
    ]));
    row.appendChild(el('div',{class:'field'},[
      el('label',{},`${f.label} length (usable)`),
      el('input',{type:'number', step:'0.5', value:data.length, onInput:(e)=>{ data.length = inches(e.target.value); }}),
    ]));
    card.appendChild(row);

    card.appendChild(el('div',{class:'row two'},[
      el('div',{class:'field'},[
        el('label',{},'Fabric name (for labels)'),
        el('input',{type:'text', value:data.name, onInput:(e)=>{ data.name = e.target.value; }}),
      ]),
      el('div',{class:'field'},[
        el('label',{},'Color / usage label'),
        el('input',{type:'text', value:colorName, onInput:(e)=>{ state.colors[f.key] = e.target.value; }}),
      ])
    ]));

    card.appendChild(el('div',{class:'hr'}));
  }

  card.appendChild(navButtons(true));
  return card;
}

function stepReview(){
  const card = el('div');
  card.appendChild(el('h2',{},'Review & generate'));
  const errs = validateInputs(state);
  if(errs.length){
    card.appendChild(el('div',{class:'notice warn'}, `Fix these before generating: ${errs.join(' · ')}`));
  } else {
    card.appendChild(el('div',{class:'notice ok'},'Inputs look good. Generate to see cut list, fabric fit, and assembly steps.'));
  }

  const summary = el('ul',{style:'text-align:left; max-width:740px; margin: 12px auto;'},[
    el('li',{},`Finished size: ${fmtIn(state.bag.L)} L × ${fmtIn(state.bag.D)} D × ${fmtIn(state.bag.H)} H`),
    el('li',{},`Seam allowance: ${fmtIn(state.seamAllowance)} · Top hem: ${fmtIn(state.topHem)}`),
    el('li',{},`Lining: ${state.lined ? 'Yes' : 'No'} · Extra bottom: ${state.extraBottom ? 'Yes' : 'No'}`),
    el('li',{},`Handles: ${state.handleStyle} · Material: ${state.handleMaterial}`),
    el('li',{},`Rotation in fabric layouts: ${state.allowRotateInFabric ? 'Allowed' : 'Not allowed'}`)
  ]);
  card.appendChild(summary);

  const bar = el('div',{class:'btnbar'});
  bar.appendChild(el('button',{class:'secondary', onClick:()=>{ stepIndex = Math.max(0, stepIndex-1); renderWizard(); }}, 'Back'));
  bar.appendChild(el('button',{onClick: generatePattern, disabled: errs.length>0}, 'Generate pattern'));
  card.appendChild(bar);

  return card;
}

// ---------- Results rendering ----------

function generatePattern(){
  const errs = validateInputs(state);
  if(errs.length){
    alert('Please fix: ' + errs.join('\n'));
    return;
  }
  const pieces = makePieces(state);
  const fabricPlan = computeFabricPlan(state, pieces);
  const steps = generateInstructions(state);

  // summary line
  $('#summaryLine').textContent = `Finished ${fmtIn(state.bag.L)} × ${fmtIn(state.bag.D)} × ${fmtIn(state.bag.H)} · Seam allowance ${fmtIn(state.seamAllowance)} · ${state.lined?'Lined':'Unlined'} · Handles: ${state.handleStyle}`;

  // fit notice
  const fitEl = $('#fitNotice');
  fitEl.className = 'notice ' + (fabricPlan.allOk ? 'ok' : 'warn');
  fitEl.textContent = fabricPlan.allOk ? 'All pattern pieces fit the provided fabric rectangles.' : 'One or more fabrics are too small—adjust dimensions or allow rotation.';

  // cut tables
  const cutHost = $('#cutTables');
  cutHost.innerHTML = '';
  cutHost.appendChild(renderCutTables(state, pieces));

  // instructions
  const instHost = $('#instructions');
  instHost.innerHTML = '';
  instHost.appendChild(renderInstructions(steps));

  // visuals
  const vizHost = $('#visuals');
  vizHost.innerHTML = '';
  vizHost.appendChild(renderVisuals(fabricPlan));

  // show results
  $('#wizard').classList.add('hidden');
  $('#results').classList.remove('hidden');
  window.scrollTo({top:0, behavior:'smooth'});
}

function exportPatternJson(){
  const pieces = makePieces(state);
  const fabricPlan = computeFabricPlan(state, pieces);
  const steps = generateInstructions(state);
  const payload = { state, pieces, fabricPlan, instructions: steps };
  const blob = new Blob([JSON.stringify(payload,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = el('a',{href:url, download:'duffel-pattern.json'});
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// ---------- Event wiring ----------

document.addEventListener('DOMContentLoaded', ()=>{
  renderWizard();
  $('#backToEdit').addEventListener('click', ()=>{
    $('#results').classList.add('hidden');
    $('#wizard').classList.remove('hidden');
    stepIndex = 0;
    renderWizard();
    window.scrollTo({top:0, behavior:'smooth'});
  });
  $('#printBtn').addEventListener('click', ()=> window.print());
  $('#exportJson').addEventListener('click', exportPatternJson);
});
</script>
</body>
</html>
